# Filtering Data {#filter}

Applying a **filter** to data (i.e., creating a **subset** of data) is an important aspect of data management. When we filter data, we can (a) select a subset of cases based based on their scores on one or more variables, or we can (b) select or remove a subset of variables. In this tutorial, you will learn some fundamental techniques for filtering your data in R.

#### Video Tutorial

Link to Video Tutorial: https://youtu.be/izVcbPmu0D0

#### Functions & Packages Introduced

Function           | Package
------------------ | ------------------
`str`              | base `R`
`filter`           | `dplyr`
`c`                | base `R`
`as.Date`          | base `R`
`select`           | `dplyr`
`subset`           | base `R`

#### Initial Steps {#initsteps_filter}

If you haven't already, save the files called **"PersData.csv"** and **"PerfData.csv"** into a folder that you will subsequently set as your working directory. Your working directory will likely be different than the one shown below (i.e., `"H:/RWorkshop"`). As a reminder, you can access all of the data files referenced in this book by downloading them as a compressed (zipped) folder from the my GitHub site: https://github.com/davidcaughlin/R-Tutorial-Data-Files; once you've followed the link to GitHub, just click "Code" (or "Download") followed by "Download ZIP", which will download all of the data files referenced in this book. For the sake of parsimony, I recommend downloading all of the data files into the same folder on your computer, which will allow you to set that same folder as your working directory for each of the chapters in this book.
  
Next, using the `setwd` function, set your working directory to the folder in which you saved the data file for this chapter. Alternatively, you can manually set your working directory folder in your drop-down menus by going to *Session > Set Working Directory > Choose Directory...*. Be sure to create a new R script file (.R) or update an existing R script file so that you can save your script and annotations. If you need refreshers on how to set your working directory and how to create and save an R script, please refer to [Setting a Working Directory](#setwd) and [Creating & Saving an R Script](#createRscript).

```{r, eval=FALSE}
# Set your working directory
setwd("H:/RWorkshop")
```

Next, read in the .csv data files called **"PersData.csv"** and **"PerfData.csv"** using your choice of read function. In this example, I use the `read_csv` function from the `readr` package [@R-readr]. If you choose to use the `read_csv` function, be sure that you have installed and accessed the `readr` package using the `install.packages` and `library` functions. *Note: You don't need to install a package every time you wish to access it; in general, I would recommend updating a package installation once ever 1-3 months.* For refreshers on installing packages and reading data into R, please refer to [Packages](#packages) and [Reading Data into R](#read).

```{r, eval=FALSE}
# Install readr package if you haven't already
# [Note: You don't need to install a package every 
# time you wish to access it]
install.packages("readr")
```
```{r}
# Access readr package
library(readr)

# Read data and name data frame (tibble) objects
personaldata <- read_csv("PersData.csv")
performancedata <- read_csv("PerfData.csv")

# View the names of the variables in the data frame (tibble) objects
names(personaldata)
names(performancedata)
```
```{r}
# View data frame (tibble) objects
personaldata
performancedata
```

As you can see from the output generated in your console, on the one hand, the `personaldata` data frame object contains basic employee demographic information. The variable names include: `id`, `lastname`, `firstname`, `startdate`, and `gender`. On the other hand, the `personaldata` data frame object contains the same `id` unique identifer variable as the  `personaldata` data frame object, but instead of employee demographic information, this data frame object includes varuables associated with quarterly employee performance: `perf_q1`, `perf_q2`, `perf_q3`, and `perf_q4`.
  
To make this chapter more interesting (and for the sake of practice), let's use the `full_join` function from `dplyr` to join (merge) the two data frames we just read in (`personaldata`, `performancedata`) using the `id` variable as the key variable. Let's arbitrarily name the new joined (merged) data frame `mergeddf` using the `<-` operator. For more information on joining data, check out the chapter called [Joining (Merging) Data](#join). 

```{r, eval=FALSE}
# Install readr package if you haven't already
# [Note: You don't need to install a package every 
# time you wish to access it]
install.packages("dplyr")
```
```{r, message=FALSE, warning=FALSE}
# Access package
library(dplyr)
```
```{r}
# Full join (without pipe)
mergeddf <- full_join(personaldata, performancedata, by="id")

# View joined (merged) data frame object
mergeddf
```

Now we have a joined data frame called `mergeddf`! 

## Filter Cases from Data Frame

Sometimes we want to select only a subset of cases from a data frame or table. There are different functions that can achieve this end. For example, the `subset` function filter from base `R` will do the trick. With that said, the `dplyr` package offers the `filter` function which has some advantages (e.g., faster with larger amounts of data), and thus, we will focus on the `filter` function in this chapter. If you would like to learn how to use the `subset` function from base R, check out the chapter supplement called [Joining (Merging) Data](#filter_supplement).
  
In order to properly filter data by cases, we need to know the respective types (classes) of the variables in the data frame. Perhaps the quickest way to find out the type (class) of each variable in the data frame is to use the `str` (structure) function from base `R`, and the function's parentheses, just enter the name of the data frame (`mergeddf`).

```{r}
# Determine class of variables
str(mergeddf)
```

Note that the `id` variable is of type integer; the `lastname`, `firstname`, `startdate`, and `gender` variables are of type character (string); and the `perf_q4`, `perf_q4`, `perf_q4`, and `perf_q4` variables are of type numeric. The variable type will have important implications for how use use the `filter` function from `dplyr`.
  
In `R`, we can apply any one of the following logical operators when filtering our data:

Logical Operator   | Definition
------------------ | ---------------------------
`<`                | "less than"
`>`                | "greater than"
`<=`               | "less than or equal to"
`>=`               | "greater than or equal to"
`==`               | "equal to"
`!=`               | "not equal to"
`|`                | "or"
`&`                | "and"
`!`                | "not"
  
To get started, install and access the `dplyr` package.

```{r, eval=FALSE}
# Install package
install.packages("dplyr")
```
```{r, message=FALSE, warning=FALSE}
# Access package
library(dplyr)
```

I will demonstrate two approaches applying the `filter` function from `dplyr`. The first option uses "pipe(s)," which in R is represented by the `%>%` operator. The pipe operator comes from a package called `magrittr`, on which the `dplyr` is partially dependent. In short, a pipe allows one to more efficiently code/script and to improve the readability of the code/script under certain conditions. Specifically, a **pipe** forwards the result or value of one object or expression to a subsequent function. In doing so, one can avoid writing functions in which other functions are nested parenthetically. The second option is more traditional and lacks the efficiency and readability of pipes. You can use either approach, and if don't you want to use pipes, skip to the section below called *Filter Data without Pipes*. For more information on the pipe operator, check out this link: https://r4ds.had.co.nz/pipes.html.

### *With* Pipes
  
Using an approach with pipes, first, use the `<-` operator to name the filtered data frame that we will create. For this example, I name the new joined data frame `filterdf`; you could name it whatever you would like. Second, type the name of the first data frame, which we  named `mergeddf` (see above), followed by the pipe (`%>%`) operator. This will "pipe" our data frame into the subsequent function. Third, either on the same line or on the next line, type the `filter` function. Fourth, within the function parentheses, type the name of the variable we wish to filter the data frame by, which in this example is `gender`. Fourth, type a logical operator, which for this example is `==`. Fifth, type a value for the filter variable, which in this example is "female"; because the `gender` variable is of type *character*, we need to put quotation marks (`" "`) around the value of the variable that we wish to filter by. Remember, object names in R are case and space sensitive; for instance, `gender` is different from `Gender`, and "female" is different from "Female".

```{r}
# Filter in by gender with pipe
filterdf <- mergeddf %>% filter(gender=="female")

# View filtered data frame
filterdf
```

Note how the data frame above contains only those cases with "female" as their `gender` variable designation. The filter worked as expected.
  
Alternatively, we could filter *out* those cases in which `gender` is equal to "female" using the `!=` (not equal to) logical operator.

```{r}
# Filter out by gender with pipe
filterdf <- mergeddf %>% filter(gender!="female")

# View filtered data frame
filterdf
```

Note how cases with `gender` equal to "female" are no longer in the data frame, while every other case is retained.
  
Let's now filter by a variable of type numeric (or integer). Specifically, let's select those cases in which the `perf_q2` variable is greater than (`>`) 4.0. Because the `perf_q2` variable is of type *numeric*, we don't use quotation marks (`" "`) around the value we wish to filter by, which in this case is 4.0. 

```{r}
# Filter by perf_q2 with pipe
filterdf <- mergeddf %>% filter(perf_q2>4.0)

# View filtered data frame
filterdf
```

If we wish to filter by two variables, we can apply the logical "or" (`|`) operator or "and" (`&`) operator. First, let's select those cases in which either `gender` is equal to "female" or `perf_q2` is greater than 4.0 using the "or" (`|`) operator.

```{r}
# Filter by gender or perf_q2 with pipe
filterdf <- mergeddf %>% filter(gender=="female" | perf_q2>4.0)

# View filtered data frame
filterdf
```

Watch what happens if we apply the logical "and" (`&`) operator with the same syntax as above.

```{r}
# Filter by gender and perf_q2 with pipe
filterdf <- mergeddf %>% filter(gender=="female" & perf_q2>4.0)

# View filtered data frame
filterdf
```

We can also use the logical "or" (`|`) operator to select two values of the same variable.

```{r}
# Filter by two values of firstname with pipe
filterdf <- mergeddf %>% filter(firstname=="John" | firstname=="Jane")

# View filtered data frame
filterdf
```

Or we can select two ranges of values from the same variable using the logical "or" (`|`) operator, assuming the variable is of type numeric, integer, or date.

```{r}
# Filter by two ranges of values of perf_q1 with pipe
filterdf <- mergeddf %>% filter(perf_q1<=2.5 | perf_q1>=4.0)

# View filtered data frame
filterdf
```

The `filter` function can also be used to remove multiple specific cases (such as from a unique identifier variable), which might be useful when you've identified outliers that need to be removed. As a first step, identify a vector of values that need to be removed. In this example, let's pretend that cases with `id` variable values of 198 and 201 no longer work for this company, so they should be removed from the sample. To create a vector of these two values, use the `c` function like this: `c(198,201)`. Next, because you are now filtering by a vector, you will need to use the `%in%` operator, which is an operator that instructs R to go through each value of the filter variable (`id`) and identify instances of 198 and 201 (`c(198,201)`); if the values match, then those cases are retained. However, because we entered `!` in front of the filter variable, this actually reverses our logic and instructs R to *remove* those cases in which a value of the filter variable matches a value contained in the vector. 

```{r error=TRUE}
# Filter out id of 198 and 201 with pipe
filterdf <- mergeddf %>% filter(!id %in% c(198,201))

# View filtered data frame
filterdf
```

Note that in the output above cases with `id` variable values equal to 198 and 201 are no longer present.
  
If you remove the `!` in front of the filter variable, only cases `198` and `201` are retained.

```{r error=TRUE}
# Filter in id of 198 and 201 with pipe
filterdf <- mergeddf %>% filter(id %in% c(198,201))

# View filtered data frame
filterdf
```

And if you wanted to remove just a single case, you could use the unique identifier variable (`id`) and the following script/code.

```{r error=TRUE}
# Filter out id of 198 with pipe
filterdf <- mergeddf %>% filter(id!=198)

# View filtered data frame
filterdf
```

When working with variables of type *Date*, things can get a bit trickier. When we applied the `str` function from base R (see above), we found that the `startdate` variable was read in and joined as a character variable as opposed to a date variable. As such, we need to convert the `startdate` variable using the `as.Date` function from base R. First, type the name of the data frame object (`mergeddf`), followed by the `$` operator and the name of whatever you want to call the new variable (`startdate2`); remember, the `$` operator tells R that a variable belongs to (or will belong to) a particular data frame. Second, type the `<-` operator. Third, type the name of the `as.Date` function. Fourth, in the function parentheses, as the first argument, enter the `as.character` function with the name of the data frame object (`mergeddf`), followed by the `$` operator and the name the original variable (`startdate`) as the sole argument. Fifth, as the second argument in the `as.Date` function, type `format="%m/%d/%Y"` to indicate the format for the data variable; note that the capital `Y` in `%Y` implies a 4-digit year, whereas a lower case would imply a 2-digit year.

```{r}
# Convert character startdate variable to the Date type startdate2 variable
mergeddf$startdate2 <- as.Date(as.character(mergeddf$startdate), format="%m/%d/%Y")
```

To verify that the new `startdate2` variable is of type date, use the `str` function from base R, and enter the name of the data frame object (`mergeddf`) as the sole argument. As you will see, the new `startdate2` variable is now of type *Date*.

```{r}
# Verify that the startdate2 variable is now a variable of type Date
str(mergeddf)
```

Now we are ready to filter using the new `startdate2` variable. When specify the value of the `startdate2` variable by which you wish to filter by, make sure to use the `as.Date` function once more with the date (formatted as YYYY-MM-DD) in quotation marks (`" "`) as the sole argument. Here, I filter for those cases in which their `startdate2` values are greater than 2016-01-07.

```{r}
# Filter by startdate2 with pipe
filterdf <- mergeddf %>% filter(startdate2 > as.Date("2016-01-07"))

# View filtered data frame
print(filterdf)
```

### *Without* Pipes

We can also filter using the `filter` function from the `dplyr` package without using the pipe (`%>%`) operator. Note how I simply move the name of the data frame object from before the pipe (`%>%`) operator to the first argument in the `filter` function. Everything else remains the same. For simplicity, I don't display the output below as it is the same as the output as above using pipes. *Your decision whether to use a pipe operator is completely up to you.*
  
Let's filter the `mergeddf` data frame object such that only those cases for which the `gender` variable is equal to "female" are retained. Note how we apply the equal to (`==`) logical operator. A table of logical operators is presented towards the beginning of this tutorial.

```{r eval=FALSE}
# Filter in by gender without pipe
filterdf <- filter(mergeddf, gender=="female")

# View filtered data frame
filterdf
```

Now let's filter *out* those cases in which `gender` is *not* equal to "female". We apply the not equal to (`!=`) logical operator to do so.

```{r eval=FALSE}
# Filter in by gender without pipe
filterdf <- filter(mergeddf, gender!="female")

# View filtered data frame
filterdf
```

Filter the data frame such that we retain those cases for which the `perf_q2` variable is greater than (`>`) 4.0. Because the `perf_q2` variable is numeric, we *don't* put the value 4.0 in quotation marks.

```{r eval=FALSE}
# Filter by perf_q2 without pipe
filterdf <- filter(mergeddf, perf_q2>4.0)

# View filtered data frame
filterdf
```

Using the logical "or" operator (`|`), select those cases for which `gender` is equal to "female" *or* for which `perf_q2` is greater than 4.0.

```{r eval=FALSE}
# Filter by gender or perf_q2 without pipe
filterdf <- filter(mergeddf, gender=="female" | perf_q2>4.0)

# View filtered data frame
filterdf
```

Using the logical "and" operator (`&`), select those cases for which `gender` is equal to "female" *and* for which `perf_q2` is greater than 4.0. Note the difference in the resulting filtered data frame.

```{r eval=FALSE}
# Filter by gender and perf_q2 without pipe
filterdf <- filter(mergeddf, gender=="female" & perf_q2>4.0)

# View filtered data frame
filterdf
```

Using the logical "or" operator (`|`), select those cases for which `firstname` is equal to "John" *or* for which `firstname` is equal to "Jane". In other words, select those individuals whose names are either "John" or "Jane".

```{r eval=FALSE}
# Filter by two values of firstname without pipe
filterdf <- filter(mergeddf, firstname=="John" | firstname=="Jane")

# View filtered data frame
filterdf
```

Using the logical "or" operator (`|`), select the range of cases for which `perf_q1` is less than equal to (`<=`) 2.5 *or* for which `perf_q1` is greater than or equal (`>=`) to 4.0.

```{r eval=FALSE}
# Filter by two ranges of values of perf_q1 without pipe
filterdf <- filter(mergeddf, perf_q1<=2.5 | perf_q1>=4.0)

# View filtered data frame
filterdf
```

The `filter` function can also be used to remove multiple specific cases (such as from a unique identifier variable), which might be useful when you've identified outliers that need to be removed. As a first step, identify a vector of values that need to be removed. In this example, let's pretend that cases with `id` variable values of 198 and 201 no longer work for this company, so they should be removed from the sample. To create a vector of these two values, use the `c` function like this: `c(198,201)`. Next, because you are now filtering by a vector, you will need to use the `%in%` operator, which is an operator that instructs R to go through each value of the filter variable (`id`) and identify instances of 198 and 201 (`c(198,201)`); if the values match, then those cases are retained. However, because we entered `!` in front of the filter variable, this actually reverses our logic and instructs R to *remove* those cases in which a value of the filter variable matches a value contained in the vector. 

```{r eval=FALSE}
# Filter out id of 198 and 201 without pipe
filterdf <- filter(mergeddf, !id %in% c(198,201))

# View filtered data frame
filterdf
```

Or if you wish to retain only those cases for which the `id` variable is equal to 198 and 201, drop the not operator (`!`) from the previous script.

```{r eval=FALSE}
# Filter in id of 198 and 201 without pipe
filterdf <- filter(mergeddf, id %in% c(198,201))

# View filtered data frame
filterdf
```

You can also drop specific cases one by one using the not equal to operator (`!=`) and the a unique identifier value associated with the case you wish to remove. We accomplish the same result as above but use two steps instead. Also, note that in the second step below, the new data frame object (`filterdf`) is used as the first argument because we want to retain the changes we made in the prior step (i.e., dropping case with `id` equal to 198).

```{r eval=FALSE}
# Filter in id of 198 without pipe
filterdf <- filter(mergeddf, id!=198)

# Filter in id of 201 without pipe
filterdf <- filter(filterdf, id!=201)

# View filtered data frame
filterdf
```

When working with variables of type *Date*, things can get a bit trickier. When we applied the `str` function from base R (see above), we found that the `startdate` variable was read in and joined as a character variable as opposed to a date variable. As such, we need to convert the `startdate` variable using the `as.Date` function from base R. First, type the name of the data frame object (`mergeddf`), followed by the `$` operator and the name of whatever you want to call the new variable (`startdate2`); remember, the `$` operator tells R that a variable belongs to (or will belong to) a particular data frame. Second, type the `<-` operator. Third, type the name of the `as.Date` function. Fourth, in the function parentheses, as the first argument, enter the `as.character` function with the name of the data frame object (`mergeddf`), followed by the `$` operator and the name the original variable (`startdate`) as the sole argument. Fifth, as the second argument in the `as.Date` function, type `format="%m/%d/%Y"` to indicate the format for the data variable; note that the capital `Y` in `%Y` implies a 4-digit year, whereas a lower case would imply a 2-digit year. To verify that the new `startdate2` variable is of type date, on the next line, use the `str` function from base R, and enter the name of the data frame object (`mergeddf`) as the sole argument. As you will see, the new `startdate2` variable is now of type *Date*.

```{r eval=FALSE}
# Convert character startdate variable to the date type startdate2 variable
mergeddf$startdate2 <- as.Date(as.character(mergeddf$startdate), format="%m/%d/%Y")

# Verify that the startdate2 variable is now a variable of type date
str(mergeddf)
```

Now we are ready to filter using the new `startdate2` variable. When specify the value of the `startdate2` variable by which you wish to filter by, make sure to use the `as.Date` function once more with the date (formatted as YYYY-MM-DD) in quotation marks (`" "`) as the sole argument. Here, I filter for those cases in which their `startdate2` values are greater than 2016-01-07.

```{r eval=FALSE}
# Filter by startdate2 without pipe
filterdf <- filter(mergeddf, startdate2 > as.Date("2016-01-07"))

# View filtered data frame
print(filterdf)
```

## Remove Single Variable from Data Frame

If you just need to remove a single variable from a data frame, using the `NULL` object in R in conjunction with the `<-` operator can designate which variable to drop. For example, if we wish to drop the `startdate` variable from the `mergeddf` data frame, we simply note that `startdate` belongs to  `mergeddf` by joining them with `$`. Next, we set `<- NULL` adjacent to `mergeddf$startdate` to indicate that we wish to remove that variable from that data frame.

```{r}
# Remove variable
mergeddf$startdate <- NULL

# View updated data frame
mergeddf
```

## Select Multiple Variables from Data Frame

If you wish to *select multiple variables* from a data frame (and remove all others), the `select` function from the `dplyr` package is quite useful and intuitive. Below,  I demonstrate how to select multiple variables with and without pipes. If you don't want to use pipes, feel free to skip down to the section called *Without Pipes*.

### *With* Pipe

Using the pipe (`%>%`) operator, first, decide whether you want to override an existing data frame or create a new data frame based on our selection; here, I override the `mergeddf` data frame using the `<-` operator, which results in `mergeddf <-`. Second, type the name of the original data frame (`mergeddf`), followed by the pipe (`%>%`) operator. Third, type the name of the `select` function. Fourth, in the parentheses, list the names of the variables you wish to select as arguments; all variables that are not listed will be dropped. Here, we are selecting (to retain) the `id`, `perf_q1`, `gender`, `lastname`, and `firstname` variables. Note that the updated date frame includes the selected variables in the order in which you listed them.

```{r}
# Select multiple variables with pipe
mergeddf <- mergeddf %>% select(id, perf_q1, gender, lastname, firstname)

# View updated data frame
mergeddf
```

### *Without* Pipe

If you decide not to use the pipe (`%>%`) operator, the syntax remains almost the same except the name of the original data frame object (`mergeddf`) is moved from before the pipe (`%>%`) operator to the first argument in the `select` function. Everything else remains the same. 

```{r eval=FALSE}
# Select multiple variables without pipe
mergeddf <- select(mergeddf, id, gender, lastname, firstname)

# View updated data frame
mergeddf
```

## Remove Multiple Variables from Data Frame

If you wish to *remove multiple variables* from a data frame, the `select` function from `dplyr` will work just fine. I demonstrate how to use this function with and without pipes. If you don't want to use pipes, feel free to skip down to the section called *Without Pipes*.

### *With* Pipe

Using the pipe (`%>%`) operator, first, decide whether you want to override an existing data frame or create a new data frame from the subset; here, I override the `mergeddf` data frame using the `<-` operator, which results in `mergeddf <-`. Second,  type the name of the original data frame (`mergeddf`), followed by the pipe (`%>%`) operator. Third, enter the `select` function. Fourth, use the `c` (combine) function with `-` in front of it to note that you want to select all other variables *except* the ones listed in the `c` function.

```{r}
# Remove multiple variables with pipe
mergeddf <- mergeddf %>% select(-c(lastname, firstname))

# View updated data frame
mergeddf
```

Removing a single variable can also be done using the `select` function. To do so, just list a single variable with `-` in front of it (as the sole argument) to indicate that you wish to drop that variable.

```{r}
# Remove single variable with pipe
mergeddf <- mergeddf %>% select(-gender)

# View updated data frame
mergeddf
```

### *Without* Pipe

If you decide *not* to use the pipe (`%>%`) operator, the syntax remains mostly the same except the name of the original data frame object (`mergeddf`) is moved from before the pipe (`%>%`) operator to the first argument in the `select` function. Everything else remains the same. 

```{r eval=FALSE}
# Remove multiple variables without pipe
mergeddf <- select(mergeddf, -c(lastname, firstname))

# View updated data frame
mergeddf
```

And here's the non-pipe equivalent to removing a single variable using this approach. 

```{r eval=FALSE}
# Remove single variable without pipe
mergeddf <- mergeddf %>% select(-gender)

# View updated data frame
mergeddf
```

## Summary

Applying filters and creating subsets of cases (rows) and variables (columns) from a data frame is an important part of data management. The `dplyr` package has two useful functions that can be used for these purposes: `filter` and `select`. 