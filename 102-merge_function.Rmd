# Joining (Merging) Data: Chapter Supplement {.unnumbered #join_supplement}

In addition to the `join` functions from the `dplyr` package covered in [Joining (Merging) Data](#join), we can use the `merge` function from base R to perform a *horizontal join*. Because this function comes from base R, we do not need to install and access an additional package like we do with the `join` functions, which some may find advantageous. 

#### Functions & Packages Introduced {.unnumbered}

Function           | Package
------------------ | ------------------
`names`            | base `R`
`merge`            | base `R`

#### Initial Steps {.unnumbered #initsteps_join_supp}

If required, please refer to the [Initial Steps](#initsteps_join) section from the chapter for more information on these initial steps.

```{r, eval=FALSE}
# Set your working directory
setwd("H:/RWorkshop")
```
```{r, eval=FALSE}
# Install readr package if you haven't already
# [Note: You don't need to install a package every 
# time you wish to access it]
install.packages("readr")
```
```{r}
# Access readr package
library(readr)

# Read data and name data frame (tibble) objects
personaldata <- read_csv("PersData.csv")
performancedata <- read_csv("PerfData.csv")

# View the names of the variables in the data frame (tibble) objects
names(personaldata)
names(performancedata)
```
```{r}
# View data frame (tibble) objects
personaldata
performancedata

# Remove case with id variable equal to 153
personaldata <- personaldata[personaldata$id != 153,]
```

## `merge` Function from Base R {.unnumbered #join_supp}

We will use the `merge` function to horizontally match cases from the `personaldata` and `performancedata` data frames using `id` as a key variable. To identify what the key variable is, let's use the `names` function from base R to retrieve the list of variable names from the two data frames, which we already did above. Nevertheless, let's call up those variable names once more. Simply enter the name of the data frame as a parenthetical argument in the `names` function.

```{r}
# Retrieve variable names from first data frame
names(personaldata)
```
```{r}
# Retrieve variable names from second data frame
names(performancedata)
```

As you can see in the variable names listed above, the `id` variable is common to both data frames, and thus it will serve as our key variable.
  
Let's begin with what is referred to as an **inner join**:

1. Use the `<-` operator to name the joined data frame that we create using the `merge` function. For this example, I name the new joined data frame `mergeddf`, which is completely arbitrary; you could name it whatever you would like. Type the name of the new joined data frame to the *left* of the `<-` operator. 
2. To the *right* of the `<-` operator, type the name of the `merge` function. Within the `merge` function parentheses, we will provide the arguments needed to make this join a reality. First, enter the name of one of the data frames (e.g., `personaldata`), followed by a comma. Second, enter the name of of the other data frame (e.g., `performancedata`), followed by a comma. Third, use the `by=` argument to indicate the name of the key variable (e.g., `id`); make sure the key variable is in quotation marks (`" "`), and remember, object and variable names in R are case and space sensitive.

```{r}
# Inner join
mergeddf <- merge(personaldata, performancedata, by="id")

# View the joined data frame
mergeddf
```

Now, let's revisit the original data frame objects that we read in initially.

```{r}
# View the first original data frame
personaldata
```
```{r}
# View the second original data frame
performancedata
```

In the output, first, note how all of the variables from the original data frames (i.e., `personaldata`, `performancedata`) are represented in the merged data frame (i.e., `mergeddf`). Second, note how the cases are matched by the `id` key variable. Third, note that the `personaldata` data frame has 8 cases, the `performancedata` data frame has 6 cases, and the `mergeddf` data frame has 6 cases. By default, the `merge` function performs an *inner join* and retains only those matched cases that have data in *both* data frames. Because cases whose `id` values were `154`, `155`, and `165` had data in `personaldata` but not `performancedata` and because the case with an `id` value equal to 153 was in `performancedata` but not `personaldata`, only the 5 cases that had available data in both data frames were retained. 
  
To perform what is referred to as a **full join** in which we retain all cases and available data, we can add the `all=` argument to our previous code and specify the logical value `TRUE`. 

```{r}
# Full join
mergeddf <- merge(personaldata, performancedata, by="id", all=TRUE)

# View the joined data frame
mergeddf
```

Note how the `full_join` function retains all available cases that had available data in at least one of the data frames, which in this example is 9 cases. *When in doubt, I recommend using the `full_join` function to retain all available data.*
  
To perform what is referred to as a **left join** in which we retain only those cases with data available in the first (left, x) data frame (`personaldata`), we use the `all.x=TRUE` argument instead.

```{r}
# Left join 
mergeddf <- merge(personaldata, performancedata, by="id", all.x=TRUE)

# View the joined data frame
mergeddf
```

Note how the *left join* retains only those cases for which the first (left, x) data frame (i.e., `personaldata`) has complete data, which in this case happens to be 8 cases. Notably absent is the case associated with `id` equal to 153 because the first (left, x) data frame (i.e., `personaldata`) lacked that case. An `NA` appears for each case from the second (right, y) data frame that contained missing values on variables from that data frame.
  
To perform what is referred to as a **right join** in which we retain only those cases with data available in the second (right, y) data frame (`performancedata`), we use the `all.y=TRUE` argument instead.

```{r}
# Right join 
mergeddf <- merge(personaldata, performancedata, by="id", all.y=TRUE)

# View the joined data frame
mergeddf
```

Note how the *right join* retains only those cases for which the joined (second, right, y) data frame (i.e., `performancedata`) has complete data. Because the first (left, x) data frame lacks data for the case in which `id` is equal to 153, an `NA` appears for each case from the first data frame that contained missing values on variables from that data frame.